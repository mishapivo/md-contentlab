# Node.js

Серверный JavaScript для бэкэнд, серверов API и веб-приложений

Node.js - это среда выполнения JavaScript, которая работает поверх механизма JavaScript с открытым исходным кодом Google, который называется V8. Сопряжение стиля JavaScript с естественным событием, асинхронного кодирования с неблокирующими библиотеками ввода-вывода делает Node.js быстрым, легким и эффективным. Этот недавно обновленный Refcard представляет узел, объясняет, как он работает, и погружается в свою архитектуру. Узнайте, как установить и использовать узел в полном объеме и получить доступ к списку наиболее часто используемых API.

![Node](https://dz2cdn1.dzone.com/storage/rc-covers/3339976-refcard-cover141.png)





СЕКЦИЯ 1

## Что такое узел?

Официальное описание в соответствии с сайтом [nodejs.org](http://www.nodejs.org/) выглядит следующим образом:

*«Платформа, построенная на основе времени выполнения JavaScript для JavaScript, для быстрого создания быстрых масштабируемых сетевых приложений».*

Перевод: Узел работает над движком JavaScript с открытым исходным кодом Google, который называется V8. Он написан на C ++ и используется в браузере Chrome от Google. Это быстро!

*«Использует управляемую событиями, неблокирующую модель ввода-вывода, которая делает ее легкой и эффективной».*

Перевод: Разработка распределенных, многопоточных приложений с использованием традиционно синхронных языков может быть сложным и сложным. Узел использует стиль асинхронного программирования JavaScript с использованием циклов событий с обратными вызовами, чтобы сделать приложения естественными быстрыми, эффективными и неблокирующими. Если вы знаете JavaScript, вы уже знаете немного об узле!

*«Идеально подходит для приложений, работающих в режиме реального времени, работающих в распределенных устройствах».*

Перевод: Многие проблемы с производительностью приложений связаны с привязкой ввода / вывода. Поскольку Node предназначен для неблокирования и управления событиями при манипулировании данными, чтении файлов или доступе к API, он идеально подходит для распределения по нескольким процессам и машинам в сети. В популярные приложения для Node входят веб-серверы, шлюзы API и серверы для мобильных приложений.

Поскольку это не ограничивается одним соединением на поток, как и большинство архитектур веб-серверов, Node масштабируется до многих тысяч одновременных подключений. Это делает его идеальным для написания мобильных и интернет-приложений Things API, которые должны взаимодействовать со многими устройствами с небольшим шагом, часто открывая соединение, пока устройство подключается к медленной сети.

РАЗДЕЛ 2

## Узел - это Javascript на сервере

Узел позволяет разработчикам писать серверные приложения в JavaScript. Серверные приложения выполняют задачи, которые не выполняются надлежащим образом на клиенте, такие как обработка и сохранение данных или файлов, а также такие задачи, как подключение к другим сетевым серверам, обслуживание веб-страниц и нажатие уведомлений. Видя, что JavaScript - это невероятно популярный язык с веб-и мобильными внешними разработчиками, способность использовать тот же самый умение для программирования серверных задач, теоретически, повышает производительность разработчика. Это также может уменьшить необходимость использования отдельных языков или кодовых баз между интерфейсом и бэкэнд-приложениями.

РАЗДЕЛ 3

## Как работает узел?

### Синхронное и асинхронное программирование

C и Java традиционно используют синхронный ввод-вывод, что означает, что время тратится впустую. Вы можете обойти это, написав многопоточные программы, но для некоторых разработчиков писать эти типы приложений в распределенной сетевой среде может быть сложной задачей. Конечно, есть также вопрос о количестве потоков, которые система может фактически породить. Узел по контрасту - это однопоточный способ программирования eventide, неблокирующих, асинхронных приложений ввода-вывода.

### Синхронный и асинхронный: по аналогии

Чтобы понять неблокирующий ввод-вывод, давайте рассмотрим общий сценарий. Предположим, вы находитесь в ресторане с друзьями.

Типичный опыт в ресторане будет примерно таким:

- Вы сидите за столом, и сервер хватает ваш заказ на напиток.
- Сервер возвращается в панель и передает ваш заказ бармену.
- Пока бармен работает над вашим напитком, сервер переходит к следующему порядку напитка.
- Сервер возвращается на панель и проходит по порядку другой таблицы.
- Прежде чем сервер вернет вам свои напитки, вы заказываете немного еды.
- Сервер передает ваш заказ на кухню.
- Теперь ваши напитки готовы, поэтому сервер подбирает их и возвращает их к столу.
- Другие столовые напитки готовы, поэтому сервер подбирает их и переносит на другой стол.
- Наконец, ваша пища готова, поэтому сервер подбирает ее и возвращает обратно к вашему столу.

В основном каждое взаимодействие с сервером следует одному и тому же шаблону. Во-первых, вы что-то заказываете. Затем сервер продолжает обрабатывать ваш заказ и возвращать его вам, когда он будет готов. Как только заказ будет передан в бар или на кухню, сервер может получить новые заказы или выполнить предыдущие заказы. Обратите внимание, что ни в какое время сервер не делает больше, чем одно. Они могут обрабатывать только один запрос за раз. Так работают неблокирующие приложения Node.js. В узле ваш код приложения похож на серверный сервер, обрабатывающий заказы, а бар / кухня - это операционная система, обрабатывающая ваши вызовы ввода-вывода.

Однопоточное приложение JavaScript отвечает за всю обработку до момента, когда требуется ввод-вывод. Затем он передает работу операционной системе, которая занимается обработкой остальных. Вернемся к примеру нашего ресторана, если каждый раз, когда сервер получил запрос на заказ, ему пришлось дождаться, когда бар / кухня закончится, прежде чем принимать следующий запрос, тогда обслуживание для этого ресторана будет очень медленным, и клиенты, скорее всего, будут недовольны. Так работает блокирующий ввод-вывод.

### Модель параллелизма циклов событий

Узел использует модель валюты в стиле браузера на сервере. Как мы все знаем, JavaScript был первоначально разработан для браузера, где события - это такие вещи, как движения мыши и клики. Перемещенная на сервер, эта же модель допускает идею цикла событий для событий сервера, таких как сетевые запросы. Вкратце, JavaScript ждет события, и всякий раз, когда это событие происходит, возникает функция обратного вызова.

Например, ваш браузер постоянно зацикливается на ожидание событий, таких как клики или мыши, но это прослушивание событий не блокирует выполнение браузером других задач. На сервере это может означать, что вместо программы, ожидающей возвращения ответа до тех пор, пока он не запросит базы данных, не обратится к файлам или не подключится к различным API-интерфейсам, он немедленно перейдет к следующему блоку работы, пока событие не вернется с каким-либо ответом , Вместо того, чтобы блокировать целые программы, ожидающие завершения ввода-вывода, цикл событий позволяет приложениям перемещаться и ждать событий, чтобы продолжить поток программы. Таким образом, узел достигает многозадачности более эффективно, чем использование потоков.

### Аналог событий

Подумайте о циклах событий как о доставке почты. Они собирают письма или события из почтового отделения (сервера). Эти буквы можно приравнять к событиям или входящим запросам, которые необходимо обрабатывать, т.е. доставлять. Бумажный носитель отправляется в каждый почтовый ящик в своей области и доставляет письма / события в почтовые ящики назначения. Эти почтовые ящики назначения можно приравнять к функциям JavaScript или ниже по течению.

Почтальон не ждет в почтовом ящике ответа. Когда пользователь почтового ящика отвечает письмом, на своих маршрутах он подбирает его. Каждый почтовый ящик имеет отдельный маршрут, и маршруты здесь можно рассматривать как обратный вызов. Каждая входящая буква / запрос имеет связанный обратный вызов, так что ответ может быть отправлен в любое время, когда он готов (асинхронно), используя маршруты обратного вызова.

### Пример кода цикла события

Давайте рассмотрим простой пример асинхронного чтения файла в буфер. Это двухэтапный процесс, в котором сначала есть запрос на чтение файла, затем обратный вызов для обработки файлового буфера (или ошибки) из чтения асинхронного файла.

```
Var  fs  =  require ( 'fs' );
```

```
Fs . ReadFile ( 'my_file . Txt ' , function ( err , data ) {
```

```
  If ( err ) throw  err ;
```

```
  Консоль . Log ( данные );
```

```
});
```

Второй аргумент **readFile** - это функция обратного вызова, которая запускается после чтения файла. Запрос на чтение файла проходит через привязки узлов к **libuv** . Затем **libuv** задает задачу чтения файла в поток. Когда поток завершает чтение файла в буфер, результат переходит к V8. Затем он проходит через привязки узлов в виде обратного вызова с буфером. В показанном обратном вызове аргумент данных имеет буфер с данными файла.

Пример HTTP-сервера с использованием узла:

```
Var  http  =  require ( 'http' );
```

```

```

```
Http . CreateServer (
```

```
  Функция ( запрос , ответ ) {
```

```
    Ответ . WriteHead ( 200 , { 'Content - Type' : 'text / plain' });
```

```
    Ответ . End ( 'Hello  World \ n' );
```

```
  }
```

```
). Слушать ( 8080 );
```

```

```

```
Консоль . Log ( «Сервер  работает  на  http : // localhost: 8080 / ');
```

РАЗДЕЛ 4

## Архитектура

Существует четыре строительных блока, которые составляют узел. Во-первых, Node инкапсулирует [libuv](https://github.com/joyent/libuv) для обработки асинхронных событий и V8 Google, чтобы обеспечить время выполнения для JavaScript. Libuv - это то, что абстрагирует всю базовую функциональность сети и файловой системы как на Windows, так и на POSIX-системах, таких как Linux, Mac OSX и Unix. Основные функциональные возможности Node, такие как Assert, HTTP, Cryptoetc., Находятся в базовой библиотеке, написанной на JavaScript. Узкие Bindingsprovide клей, соединяющий эти технологии друг с другом и с операционной системой.

- Как мы видели [, V8 от Google](https://developers.google.com/v8/) обеспечивает время выполнения для JavaScript.
- Libuv C - это библиотека C, которая обрабатывает асинхронные операции ввода-вывода и абстрагирует базовые функции сети и файловой системы, поэтому Node может работать на разных платформах операционной системы.
- [Ядро узла](https://nodejs.org/dist/latest-v4.x/docs/api/) - это библиотека JavaScript, которая включает в себя такие модули, как Assert, HTTP, Crypto и т. Д., Которая предоставляет базовый JavaScript API для Node.
- Связывание узлов обеспечивает клей, соединяющий эти технологии друг с другом и с операционной системой.

РАЗДЕЛ 5

## Как установить узел?

Хорошей новостью является то, что установщики существуют для различных платформ, включая Windows, Mac OS X, Linux, SunOS, и, конечно же, вы можете скомпилировать их из источника. Официальные загрузки доступны на сайте nodejs.org: [http://nodejs.org/download/](http://nodejs.org/download/)

РАЗДЕЛ 6

## Каковы эксплуатационные характеристики узла?

Все знают, что эталонные показатели являются конкретным измерением и не учитывают все случаи. Конечно, что и как вы много измеряете. Но есть одна вещь, о которой мы все можем договориться: на высоких уровнях параллелизма (тысячи подключений) ваш сервер должен стать асинхронным и неблокирующим. Мы могли бы завершить это предложение с помощью ввода-вывода, но проблема в том, что если какая-либо часть блоков вашего сервера блокируется, вам понадобится поток. На этих уровнях параллелизма вы не можете создавать потоки для каждого подключения. Таким образом, весь путь кода должен быть неблокирующим и асинхронным, а не только слоем ввода-вывода. Это то, где Node превосходит.

Вот коллекция статей и блогов о производительности [узла](http://strongloop.com/node-js/performance/) : производительность [узлов и контрольные показатели](http://strongloop.com/node-js/performance/)

РАЗДЕЛ 7

## Для чего нужен узел?

### Веб-приложения

Узел становится популярным для веб-приложений, потому что веб-приложения теперь медленно переходят от чисто серверной рендеринга к одностраничным приложениям, чтобы оптимизировать работу пользователя на стороне клиента.

Причины, почему:

- Одностраничные приложения имеют парадигму MVC, автономную в браузере, так что единственное взаимодействие на стороне сервера, которое требуется, может быть через эффективный API для вызова RPC функций на стороне сервера и данных за брандмауэром или в облаке
- Богатые экосистемные модули узла Nomm позволяют создавать веб-приложения спереди назад с относительной легкостью языка сценариев, который уже повсеместно понимается на лицевой стороне
- Приложения и узлы с одной страницей построены на общем динамическом языке сценариев JavaScript

Примеры рамок для узла:

- [экспресс](http://expressjs.com/)
- [Sails.js](http://sailsjs.org/)
- [Compound.js](http://compoundjs.com/)
- [Flatiron.js](http://flatironjs.org/)
- [Derby.js](http://derbyjs.com/)
- [Socketstream.js](https://github.com/socketstream/socketstream)
- [метеор](http://www.meteor.com/)
- [Tower.js](http://tower.github.io/)

### Мобильные бэкэнды

Узел популярен для бэкэнд, особенно для мобильных приложений. Будучи библиотекой ввода-вывода в основе, удобство использования Node было применено к классическому случаю использования корпоративных приложений, чтобы иметь возможность собирать и нормализовать существующие данные и сервисы.

Причины, почему:

- Поскольку переход на гибридные мобильные приложения становится более доминирующим на предприятии, повторное использование кода, написанного на JavaScript на стороне клиента, может быть задействовано на сервере
- Богатая экосистема Узла имеет почти каждый базовый драйвер или соединитель для корпоративных источников данных, таких как РСУБД, файлы, NoSQL и т. Д., Которые будут представлять интерес для мобильных клиентов
- Использование узла JavaScript в качестве языка сценариев упрощает нормализацию данных в мобильных API

Примеры мобильных бэкендов, построенных в узле:

- [Анализ (Собственный)](http://parse.com/)
- [LoopBack (с открытым исходным кодом)](https://github.com/strongloop/loopback)
- [FeedHenry (Собственный)](http://www.feedhenry.com/)
- [Облачные сервисы Appellererator (Собственные)](http://www.appcelerator.com/)

### Серверы API

Поскольку все больше и больше объектов на рабочем месте, дома и за его пределами подключены к «Интернету вещей», Node.js становится технологией сервера для многих платформ IoT.

Причины, почему:

- Датчики, сообщающие о температуре, скорости транспортного средства и т. Д., Могут генерировать множество точек данных, каждый из которых не меньше одного. Node.js создан для эффективного использования такого рода «много запросов, небольших полезных нагрузок».
- Популярность Node.js как платформы для построения API-интерфейсов означает, что ее сильные и слабые стороны здесь хорошо изучены, и существует множество зрелых решений, которые соответствуют требованиям IoT.

Примеры серверов IoT с открытым исходным кодом, построенных в узле:

- [Zetta](http://www.zettajs.org/)
- [MQTT-соединение](https://www.npmjs.com/package/mqtt-connection)
- [Adafruit-ю](https://github.com/adafruit/adafruit-io-node)
- [Phant](https://github.com/sparkfun/phant)

РАЗДЕЛ 8

## Как я могу сделать узел полезным?

### Что такое npm?

Диспетчер пакетов узлов (nomm) - это менеджер пакетов командной строки для узла, который управляет зависимостями для вашего приложения. [Npmjs.org](https://npmjs.org/) - это публичный репозиторий, в котором вы можете получать и публиковать модули.

### Как работает npm?

Для того, чтобы ваше приложение Node было полезным, ему понадобятся такие вещи, как библиотеки, веб-и тестовые среды, возможность подключения к данным, парсеры и другие функции. Вы включаете эту функцию, устанавливая определенные модули через npm.

Не нужно устанавливать, чтобы начать использовать npm, если вы уже используете Node v0.6.3 или новее.

Вы можете установить любой пакет с помощью этой команды:

```
$ Npm  install
```

Некоторые популярные и наиболее часто используемые модули включают в себя:

- [Express](https://npmjs.org/package/express) : быстрый, неприкрытый, минималистский веб-интерфейс для узла. Экспресс стремится предоставлять небольшие, надежные инструменты для HTTP-серверов, что делает его отличным решением для одностраничных приложений, веб-сайтов, гибридов или общедоступных HTTP-API.
- [Lodash](https://lodash.com/) : Lodash - это утилитная библиотека инструментов с инструментами для выполнения множества общих задач JavaScript. Он может использоваться автономно, в сочетании с другими небольшими библиотеками или в контексте более крупной структуры.
- [асинхронный](https://www.npmjs.org/package/async) : Асинхронный представляет собой модуль утилита , которая предоставляет простые и мощные функции для работы с асинхронным JavaScript. Хотя он изначально предназначен для использования с узлом, его также можно использовать непосредственно в браузере. Async предоставляет около 20 функций, которые включают в себя обычные «функциональные» подозреваемые (карту, уменьшить, фильтровать, каждый ...) в дополнение к вашей асинхронной функции.
- [Request](https://www.npmjs.org/package/request) : упрощенный клиент HTTP-запроса. Он поддерживает HTTPS и после перенаправления по умолчанию.
- [Grunt](https://npmjs.org/package/grunt) : бегун JavaScript-задачи, который помогает автоматизировать задачи. Grunt может выполнять повторяющиеся задачи, такие как минификация, компиляция, модульное тестирование, листинг и т. Д. Эту систему Grunt также довольно большую, и на ней могут быть сотни плагинов. Здесь вы можете найти список плагинов.
- [Socket.io](https://npmjs.org/package/socket.io) : Socket.io позволяет использовать WebSockets и в реальном времени во всех браузерах и обеспечивает встроенное мультиплексирование, масштабируемость по горизонтали, автоматическое кодирование / декодирование JSON и многое другое.
- [Mongoose](https://npmjs.org/package/mongoose) : инструмент моделирования объектов MongoDB, предназначенный для работы в асинхронной среде. Он включает в себя встроенный тип каста, валидацию, построение запросов, крючки бизнес-логики и многое другое, из коробки.

РАЗДЕЛ 9

## Как Node.js поддерживается и улучшается на повседневной основе?

Некоторые люди могут не знать различные группы высокого уровня Node.js и то, как происходит повседневная работа над Node.js. Давайте рассмотрим различные группы и как они все работают на узле.

[Совет Фонда Node.js](https://nodejs.org/en/foundation/board/) , состоящий из представителей корпоративных членов, представителя Технического руководящего комитета и избранных представителей отдельных членов класса, не занимается повседневной работой. Вместо этого обязанности правления в первую очередь:

- Установить бизнес / техническое направление
- Надзор за управлением интеллектуальной собственностью (ИС)
- маркетинг
- планировка события

[Технический руководящий комитет](https://github.com/nodejs/tsc) (TSC), являющийся техническим органом Node.js Foundation, не занимается повседневной работой. Он допускает и сохраняет контроль над всеми проектами высшего уровня в рамках компетенции Фонда Node.js.

[Основной технический комитет](https://github.com/nodejs/ctc) , который отвечает за текущее обслуживание и развитие Node.js, а также за продвижение проекта и сообщества вперед, ежедневно обрабатывает технические решения, однако только тогда, когда их нужно сделать. (Смотрите ниже для получения дополнительной информации.)

Прежде всего, работа над разработкой ядра Node.js регулируется распределенной моделью консенсуса, управляемой группой [сотрудников](https://github.com/nodejs/node#collaborators) .

Процесс идет примерно следующим образом:

- Запрос на перенос делается против хранилища
- Если более одного соавтора согласны с тем, что он должен быть объединен, он будет двигаться вперед
- PR должен приземлиться в течение 48 часов (72, если в выходные дни)

Единственный раз, когда решение принимается в КТК, - это когда невозможно достичь консенсуса. [График выпуска Node.js](https://nodejs.org/en/about/releases/) свободно соответствовать следующим требованиям:

- Приращения основного семестра происходят раз в два года
- Текущие выпуски могут происходить еженедельно или раз в две недели
- Выбросы LTS колеблются в зависимости от потребностей; Как правило, в начале термина LTS, релизы происходят каждые две недели, но это замедляется ежемесячно. (Только выпущенные номера выпускаются в LTS.)

Более подробную информацию можно найти в [Руководстве](https://github.com/nodejs/node/blob/master/COLLABORATOR_GUIDE.md) по [совместной работе](https://github.com/nodejs/node/blob/master/COLLABORATOR_GUIDE.md) .

### Руководство по API Node

Ниже приведен список наиболее часто используемых API-интерфейсов узлов. Полный список и текущее состояние стабильности API или разработки [API см. В документации по API Node](http://nodejs.org/api/) .

[Буферные](http://nodejs.org/api/buffer.html)
функции для управления, создания и потребления октетных потоков, с которыми вы можете столкнуться при работе с потоками TCP или файловой системой. Исходные данные хранятся в экземплярах класса Buffer. Буфер похож на массив целых чисел, но соответствует распределению необработанной памяти вне кучи V8. Буфер не может быть изменен.

Функции [дочернего процесса](http://nodejs.org/api/child_process.html) для нереста новых процессов и обработки их ввода и вывода. Узел обеспечивает трехстороннюю функцию popen (3) через модуль child_process.

[Кластер](http://nodejs.org/api/cluster.html)
Один экземпляр узла работает в одном потоке. Чтобы использовать многоядерные системы, пользователь иногда захочет запустить кластер процессов узла для обработки нагрузки. Модуль кластера позволяет вам легко создавать дочерние процессы, которые используют общие порты сервера.

[Crypto](http://nodejs.org/api/crypto.html)
Функции для работы с безопасными учетными данными, которые вы можете использовать в соединении HTTPS. Crypto-модуль предлагает способ инкапсуляции безопасных учетных данных, которые будут использоваться как часть защищенной сети HTTPS или http-соединения. Он также предлагает набор оберток для хэша, hmac, шифрования, расшифровки, подписи и проверки OpenSSL.

[Отладчик.](http://nodejs.org/api/debugger.html)
Вы можете получить доступ к отладчику двигателя V8 с помощью встроенного клиента Node и использовать его для отладки собственных сценариев. Просто запустите узел с аргументом отладки ( **node debug server.js** ). Более функциональным альтернативным отладчиком является [инспектор узлов](https://npmjs.org/package/node-inspector) . Он использует Blink DevTools от Google, позволяет вам перемещаться по исходным файлам, устанавливать контрольные точки и редактировать переменные и свойства объектов, между прочим.

[События](http://nodejs.org/api/events.html)
Содержит класс **EventEmitter,** используемый многими другими объектами Node. События определяют API для присоединения и удаления прослушивателей событий и взаимодействия с ними. Как правило, имена событий представлены строкой с верблюжьей линией; Однако нет никаких строгих ограничений на случай, поскольку любая строка будет принята. Затем функции могут быть привязаны к объектам, которые должны выполняться при испускании события. Эти функции называются **слушателями** . Внутри функции прослушивателя объектом является **EventEmitter** , к которому был присоединен слушатель. Все EventEmitters испускают событие **newListener** (при добавлении новых слушателей) и removeListener (при удалении слушателя).

Для доступа к классу EventEmitter используйте:

```
Require ( «события» ). EventEmitter .
```

```

```

```
Эмиттер . на ( событие , слушатель ) добавляет  к  слушателю ,  чтобы  в  конце концов  из  за  слушателей  массива 
```

```
для  в  указанном  случае . Для  примера :
```

```

```

```
Сервер . On ( 'connection' , function ( stream ) {
```

```
  Консоль . Log ( «кто-то  связан ! » );
```

```
});
```

Это вызывает возврат эмиттера, а это означает, что вызовы могут быть привязаны.

[Globals](http://nodejs.org/api/globals.html)
Globals позволяют размещать объекты во всех модулях. (За исключением случаев, отмеченных в документации.)

[HTTP](http://nodejs.org/api/http.html)
Это самый важный и наиболее используемый модуль для веб-разработчика. Он позволяет создавать HTTP-серверы и заставить их прослушивать данный порт. Он также содержит объекты **запроса** и **ответа** , содержащие информацию о входящих запросах и исходящих ответах. Вы также используете это, чтобы делать HTTP-запросы из своего приложения и делать что-то со своими ответами. Заголовки HTTP-сообщений представлены таким объектом:

```
{ 'Содержание - длина' : '123' ,
```

```
  «содержание - тип» : «текст / равнина» ,
```

```
  «соединение» : «держать - живой» ,
```

```
  'Accept' : ' * / *'}
```

Для поддержки полного спектра возможных HTTP-приложений HTTP API-интерфейс Node является очень низким. Речь идет только об обработке потоков и синтаксисе сообщений. Он анализирует сообщение в заголовки и тело, но не анализирует фактические заголовки или тело.

[Модули](http://nodejs.org/api/modules.html)

Узел имеет простую систему загрузки модуля. В узле файлы и модули соответствуют друг другу. Например, foo.js загружает модуль circle.js в тот же каталог.

Содержимое foo.js:

```
Var  circle  =  require ( ' . / Circle . Js' );
```

```
Консоль . войти ( «The  область  из  более  окружностей  от  радиуса  4  является  »
```

```
  +  Круг . Площадь ( 4 ));
```

Содержимое circle.js:

```
Var  PI  =  Math . PI ;
```

```

```

```
Экспорта . Area  =  function ( r ) {
```

```
  Return  PI  *  r  *  r ;
```

```
};
```

```

```

```
Экспорта . Окружность  =  функция ( r ) {
```

```
  Return  2  *  PI  *  r ;
```

```
};
```

Модуль circle.js экспортировал области функций **()** и **окружность ()** .

Чтобы добавить функции и объекты в корень вашего модуля, вы можете добавить их в специальный объект экспорта. Переменные, локальные для модуля, будут закрытыми, как если бы модуль был завернут в функцию. В этом примере переменная PI является частной для circle.js.

[Net](http://nodejs.org/api/net.html)
Net - одна из наиболее важных функций в ядре Node. Он позволяет создавать объекты сетевого сервера для прослушивания соединений и действовать на них. Он позволяет считывать и записывать сокеты. В большинстве случаев, если вы работаете над веб-приложениями, вы не будете напрямую взаимодействовать с сетью. Вместо этого вы будете использовать **HTTP-**модуль для создания HTTP-специфических серверов. Если вы хотите создавать TCP-серверы или сокеты и взаимодействовать с ними напрямую, вам нужно будет работать с Net API.

[Процесс](http://nodejs.org/api/process.html)
Используется для доступа к аргументам командной строки stdin, stdout, командной строки, идентификатору процесса, переменным среды и другим элементам системы, связанным с выполняемыми в настоящее время процессами узла. Это экземпляр **EventEmitter** . Вот пример прослушивания **uncaughtException:**

```
Процесс . на ( 'uncaughtException' , функция ( ERR ) {
```

```
  Консоль . Log ( 'Caught  exception : '  +  err );
```

```
});
```

```

```

```
SetTimeout ( function () {
```

```
  Консоль . Log ( 'Это  все  равно  будет работать . ' );
```

```
}, 500 );
```

```

```

```
// Преднамеренно вызывать исключение, но не поймать его.
```

```
NonexistentFunc ();
```

```
Консоль . Log ( 'Это  не будет  работать . ' ); 
```

[РЕПЛ](http://nodejs.org/api/repl.html)
Стенды для **R** ead- **E** Val- **P** rint- **L** уп. Вы можете добавить REPL к своим собственным программам, так же как автономный REPL от Node, который вы получаете при запуске узла без аргументов. REPL может использоваться для отладки или тестирования.

[Поток](http://nodejs.org/api/stream.html)
Абстрактный интерфейс для потоковой передачи данных, который реализуется другими объектами узла, такими как запросы HTTP-сервера и даже stdio. Большую часть времени вы захотите проконсультироваться с документацией для фактического объекта, с которым работаете, вместо того, чтобы смотреть на определение интерфейса. Потоки доступны для чтения, для записи или для обоих. Все потоки являются экземплярами [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter) .

[VM](http://nodejs.org/api/vm.html)
Позволяет вам скомпилировать произвольный код JavaScript и, возможно, немедленно выполнить его в новой изолированной среде или сохранить для каждого клиента, а каждый сервер - позже.

РАЗДЕЛ 10

## Инструменты разработчика для узла

Ниже приведены некоторые ключевые инструменты, широко используемые на предприятии и в сообществе для разработки приложений узлов:

### Среда разработки

| **ПРОДУКТ / ПРОЕКТ**                     | **ОСОБЕННОСТИ / ОСНОВНЫЕ МОМЕНТЫ**       |
| ---------------------------------------- | ---------------------------------------- |
| [WebStorm](http://www.jetbrains.com/webstorm/) | Анализ кодаКросс-платформеннаяИнтеграция VCS |
| [Возвышенный текст](http://www.sublimetext.com/2) | Перейти к чему угодноНастраиваемыйКросс-платформенная |
| [фазаний выводок](http://coreh.github.io/nide/) | Отображение дерева проектаИнтеграция NpmКомандная строка и Mac |
| [Nodeclipse](http://www.nodeclipse.org/) | Открытый исходный кодПостроено на Eclipse |
| [Cloud9 IDE](https://c9.io/)             | Облако основесовместныйОтладка и развертывание |
| [IntelliJ](http://www.jetbrains.com/idea/) | Плагин узлаЗавершение кодаАнализ кода    |

### Мониторинг производительности приложений

| **ПРОДУКТ / ПРОЕКТ**                     | **ОСОБЕННОСТИ / ОСНОВНЫЕ МОМЕНТЫ**       |
| ---------------------------------------- | ---------------------------------------- |
| [StrongOps](http://strongloop.com/node-js-performance/strongops/) | Прослеживание ошибокВремя отклика циклаСамые медленные конечные точки |
| [Новая реликвия](http://newrelic.com/nodejs) | Коэффициенты ошибокВремя реакции транзакцииКонтроль пропускной способности |
| [AppDynamics](http://www.appdynamics.com/solutions/nodejs-monitoring) | Прослеживание ошибокВремя отклика конечной точкиИсторические показатели |

### отладка

| **ПРОДУКТ / ПРОЕКТ**                     | **ОСОБЕННОСТИ / ОСНОВНЫЕ МОМЕНТЫ**       |
| ---------------------------------------- | ---------------------------------------- |
| [Отладчик V8](https://code.google.com/p/v8/wiki/DebuggerProtocol) | Ручная инъекция кодаКонтрольные точкиОбработка исключений событий |
| [StrongOps - Инспектор узлов](https://github.com/node-inspector/node-inspector) | Google Blink Dev-Tools основан           |
| [Cloud9 IDE](https://c9.io/)             | Облако основеЗавершение кодаОтладка и развертывание |
| [WebStorm](http://www.jetbrains.com/webstorm/) | Анализ кодаКросс-платформеннаяИнтеграция VCS |
| [Nodeclipse](http://www.nodeclipse.org/) | Завершение кодаВстроенный EclipseТрассировка и точки останова |
| [DTrace](http://dtrace.org/)             | Только SmartOSТрассировка транзакций     |

РАЗДЕЛ 11

## Ресурсы

- Сайт [StrongLoop](http://strongloop.com/)
- [Технический блог](http://strongloop.com/strongblog/) StrongLoop
- Официальный [сайт узла](http://nodejs.org/)
- [Загрузка узлов](http://nodejs.org/download/)
- [Документация по узлам](http://nodejs.org/api/)
- [Узел на GitHub](https://github.com/joyent/node)
- Официальный [сайт npm](https://npmjs.org/)
- [Документация npm](https://www.npmjs.org/doc/)
- [Узел LinkedIn Group](http://www.linkedin.com/groups/Nodejs-2906459)
# [Шаблоны проектирования](https://dzone.com/refcardz/design-patterns)

Создание универсального и масштабируемого программного обеспечения.

Изучите образцы дизайна быстро с выдающимся учебником Джейсона Макдональда по оригинальным шаблонам дизайна 23 Gang of Four, включая диаграммы классов, объяснения, информацию об использовании и примеры реальных мировых событий.



СЕКЦИЯ 1

## О шаблонах проектирования

Эта обратная карта Design Patterns обеспечивает быструю ссылку на исходные шаблоны дизайна 23 Gang of Four, перечисленные в книге Design Patterns: Elements of Reusable Object-Oriented Software. Каждый шаблон включает диаграммы классов, объяснение, информацию об использовании и пример реального мира.

- **Creational Patterns:** Используется для построения объектов, которые могут быть отделены от их внедряющей системы.
- **Структурные шаблоны.** Используются для формирования больших объектов между многими несопоставимыми объектами.
- **Поведенческие шаблоны:** используется для управления алгоритмами, отношениями и обязанностями между объектами.
- Object Scope: Сделки с объектными отношениями, которые могут быть изменены во время выполнения.
- Класс Scope: Сделки с отношениями классов, которые могут быть изменены во время компиляции.

| С    | Абстрактная фабрика     | S    | декоратор       | С    | Опытный образец |
| ---- | ----------------------- | ---- | --------------- | ---- | --------------- |
| S    | адаптер                 | S    | Фасад           | S    | полномочие      |
| S    | Мост                    | С    | Заводской метод | В    | наблюдатель     |
| С    | строитель               | S    | легкий вес      | С    | одиночка        |
| В    | Цепочка ответственности | В    | переводчик      | В    | состояние       |
| В    | команда                 | В    | медиатор        | В    | Метод шаблона   |
| S    | композитный             | В    | сувенир         | В    | посетитель      |

РАЗДЕЛ 2

## Цепочка ответственности Объект Поведенческий

![Схема диаграммы ответственности](https://dzone.com/storage/rc-covers/10609-thumb.png)

### Цель

Предоставляет более одного объекта возможность обрабатывать запрос, связывая принимающие объекты вместе.

#### Использовать Когда

- Несколько объектов могут обрабатывать запрос, и обработчик не должен быть конкретным объектом.
- Набор объектов должен иметь возможность обрабатывать запрос с обработчиком, определенным во время выполнения.
- Прием, который не обрабатывается, является приемлемым потенциальным результатом.

#### пример

Обработка исключений на некоторых языках реализует этот шаблон. Когда в методе генерируется исключение, среда выполнения проверяет, имеет ли метод механизм для обработки исключения или если он должен быть передан стек вызовов. Когда передается стек вызовов, процесс повторяется до тех пор, пока не встретится код для обработки исключения, или пока не будет больше родительских объектов для передачи запроса.

РАЗДЕЛ 3

## Командный объект поведенческий

![Схема диаграммы команд](https://dzone.com/storage/rc-covers/10610-thumb.png)

### Цель

Инкапсулирует запрос, разрешающий его рассматривать как объект. Это позволяет обрабатывать запрос в традиционно объектно-ориентированных отношениях, таких как очередь и обратные вызовы.

#### Использовать Когда

- Вам нужна функция обратного вызова.
- Запросы должны обрабатываться в разное время или в вариантных заказах.
- Требуется история запросов.
- Вызов должен быть отделен от объекта, обрабатывающего вызов.

#### пример

Очереди работы широко используются для облегчения асинхронной обработки алгоритмов. Путем использования шаблона команды функциональность, которая должна быть выполнена, может быть предоставлена очереди заданий для обработки без необходимости того, чтобы очередь имела информацию о фактической реализации, которую она вызывает. Объект команды, который находится в очереди, реализует свой конкретный алгоритм в пределах интерфейса, ожидаемого очередью.

РАЗДЕЛ 4

## Интерпретатор Класс Поведенческий

![Диаграмма шаблонов переводчиков](https://dzone.com/storage/rc-covers/10611-thumb.png)

### Цель

Определяет представление для грамматики, а также механизм для понимания грамматики и ее действия.

#### Использовать Когда

- Существует грамматика для интерпретации, которая может быть представлена как большие синтаксические деревья.
- Грамматика проста.
- Эффективность не важна.
- Желательна развязка грамматики из основных выражений.

#### пример

Хорошим примером этого являются текстовые приключения, чрезвычайно популярные в 1980-х годах. У многих были простые команды, такие как «уйти в отставку», что позволило обходить игру. Эти команды могут быть вложены так, чтобы они изменили их смысл. Например, «войти» приведет к другому результату, чем «идти вверх». Создавая иерархию команд на основе команды и квалификатора (нетерминальные и терминальные выражения), приложение может легко сопоставить многие варианты команд с соответствующим деревом действий.

РАЗДЕЛ 5

## Итераторский объект поведенческий

![Диаграмма рисунка итератора](https://dzone.com/storage/rc-covers/10612-thumb.png)

### Цель

Позволяет получить доступ к элементам совокупного объекта, не допуская доступа к его базовому представлению.

#### Использовать Когда

- Доступ к элементам необходим без доступа ко всему представлению.
- Требуются множественные или параллельные обходы элементов.
- Требуется единый интерфейс для обхода.
- Между деталями реализации различных итераторов существуют тонкие различия.

#### пример

Java-реализация шаблона итератора позволяет пользователям перемещаться по различным типам наборов данных, не беспокоясь о базовой реализации коллекции. Поскольку клиенты просто взаимодействуют с интерфейсом итератора, коллекции оставляют для определения соответствующего итератора для себя. Некоторые из них позволят получить полный доступ к базовому набору данных, в то время как другие могут ограничить определенные функции, такие как удаление элементов.

РАЗДЕЛ 6

## Посредник

![Схема диаграммы посредника](https://dzone.com/storage/rc-covers/10613-thumb.png)

### Цель

Позволяет свободно связывать, инкапсулируя способ взаимодействия разных групп объектов и общения друг с другом. Позволяет изменять действия каждого объекта независимо друг от друга.

#### Использовать Когда

- Связь между наборами объектов хорошо определена и сложна.
- Слишком много отношений существует, и необходима общая точка управления или коммуникации.

#### пример

Программное обеспечение списка рассылки отслеживает, кто зарегистрирован в списке рассылки, и предоставляет единую точку доступа, через которую любой человек может общаться со всем списком. Без реализации медиатора человек, желающий отправить сообщение группе, должен будет постоянно отслеживать, кто был зарегистрирован, а кто нет. Внедряя шаблон посредника, система может принимать сообщения из любой точки, а затем определять, какие получатели должны пересылать сообщение, без того, чтобы отправитель сообщения имел отношение к фактическому списку получателей.

РАЗДЕЛ 7

## Memento Object Behavioral

![Диаграмма диаграммы Memento](https://dzone.com/storage/rc-covers/10614-thumb.png)

### Цель

Позволяет захватывать и экстернализировать внутреннее состояние объекта, чтобы его можно было восстановить позже, без нарушения инкапсуляции.

#### Использовать Когда

- Внутреннее состояние объекта должно быть сохранено и восстановлено позднее.
- Внутреннее состояние не может быть обнаружено интерфейсами без демонстрации реализации.
- Границы инкапсуляции должны быть сохранены.

#### пример

Функцию отмены можно легко реализовать с использованием шаблона памяти. Посредством сериализации и десериализации состояния объекта перед тем, как произойдет изменение, мы можем сохранить его снимок, который впоследствии может быть восстановлен, если пользователь решит отменить операцию.

РАЗДЕЛ 8

## Поведение наблюдателя

![Схема диаграммы наблюдателя](https://dzone.com/storage/rc-covers/10615-thumb.png)

### Цель

Позволяет уведомлять один или несколько объектов о изменениях состояния других объектов внутри системы.

#### Использовать Когда

- Изменения состояния в одном или нескольких объектах должны приводить к поведению в других объектах
- Требуются возможности вещания.
- Существует понимание того, что объекты будут слепы к расходам на уведомление.

#### пример

Этот шаблон можно найти почти в каждой среде графического интерфейса. Когда кнопки, текст и другие поля помещаются в приложения, приложение обычно регистрируется как слушатель для этих элементов управления. Когда пользователь запускает событие, например, нажатие кнопки, элемент управления выполняет итерацию через своих зарегистрированных наблюдателей и отправляет уведомление каждому из них.

РАЗДЕЛ 9

## Поведение

![Диаграмма состояний](https://dzone.com/storage/rc-covers/10616-thumb.png)

### Цель

Связывает обстоятельства объекта с его поведением, позволяя объекту вести себя по-разному на основе его внутреннего состояния.

#### Использовать Когда

- Его поведение зависит от поведения объекта.
- Сложные условия связывают поведение объекта с его состоянием.
- Переходы между государствами должны быть явными.

#### пример

Объект электронной почты может иметь различные состояния, все из которых будут изменять способ обработки различными функциями объекта. Если состояние «не отправлено», тогда вызов send () отправит сообщение, в то время как вызов функции отзываMessage () либо выдаст ошибку, либо ничего не сделает. Однако, если состояние «отправлено», вызов send () будет либо выдавать ошибку, либо ничего не делать, в то время как вызов функции отзываMessage () будет пытаться отправить уведомление об отзыве получателям. Чтобы избежать условных операторов в большинстве или во всех методах, было бы несколько объектов состояния, которые обрабатывают реализацию по отношению к их конкретному состоянию. Затем вызовы в объекте электронной почты будут делегированы до соответствующего объекта состояния для обработки.

РАЗДЕЛ 10

## Стратегический объект Поведенческий

![Схема диаграммы стратегии](https://dzone.com/storage/rc-covers/10617-thumb.png)

### Цель

Определяет набор инкапсулированных алгоритмов, которые могут быть заменены для выполнения определенного поведения.

#### Использовать Когда

- Единственное различие между многими связанными классами - это их поведение.
- Требуется несколько версий или вариантов алгоритма.
- Алгоритмы доступа или использования данных, вызывающих код, не должны подвергаться.
- Поведение класса должно определяться во время выполнения.
- Условные утверждения сложны и трудно поддерживать.

#### пример

При импорте данных в новую систему могут выполняться различные алгоритмы проверки на основе набора данных. Конфигурируя импорт для использования стратегий, условная логика определяет, какая проверка, установленная для запуска, может быть удалена, а импорт может быть отделен от фактического кода проверки. Это позволит нам динамически вызывать одну или несколько стратегий во время импорта.

РАЗДЕЛ 11

## Тип шаблона Класс Поведенческий

![Шаблон стратегии шаблона](https://dzone.com/storage/rc-covers/10618-thumb.png)

### Цель

Определяет структуру алгоритма, позволяя реализовать классы для определения фактического поведения.

#### Использовать Когда

- Требуется одна абстрактная реализация алгоритма.
- Общее поведение между подклассами должно быть локализовано в общий класс.
- Родительские классы должны иметь возможность равномерно вызывать поведение в своих подклассах.
- Большинство или все подклассы должны реализовывать поведение.

#### пример

Родительский класс InstantMessage, вероятно, будет иметь все методы, необходимые для обработки отправки сообщения. Однако фактическая сериализация отправляемых данных может варьироваться в зависимости от реализации. Для правильной сериализации данных для видеосообщения и обычного текстового сообщения потребуются разные алгоритмы. Подклассы InstantMessage могут обеспечить собственную реализацию метода сериализации, позволяя родительскому классу работать с ними, не понимая их деталей реализации.

РАЗДЕЛ 12

## Поведение посетителя

![Диаграмма диаграмм посетителей](https://dzone.com/storage/rc-covers/10619-thumb.png)

### Цель

Позволяет применять одну или несколько операций к набору объектов во время выполнения, отделяя операции от структуры объекта.

#### Использовать Когда

- Структура объекта должна иметь много несвязанных операций, выполняемых над ним.
- Структура объекта не может измениться, но операции, выполняемые на нем, могут быть.
- Операции должны выполняться над конкретными классами структуры объекта.
- Приемлемым является внутреннее состояние или операции структуры объекта.
- Операции должны иметь возможность работать с несколькими структурами объектов, которые реализуют одни и те же наборы интерфейсов.

#### пример

Вычисление налогов в разных регионах по наборам счетов-фактур потребует много разных вариантов логики расчета. Реализация посетителя позволяет отделить логику от счетов-фактур и позиций. Это позволяет иерархии элементов посещать код расчета, который затем может применять соответствующие ставки для региона. Изменение регионов так же просто, как замена другого посетителя.

РАЗДЕЛ 13

## Класс адаптера и объект

![Схема диаграммы адаптера](https://dzone.com/storage/rc-covers/10620-thumb.png)

### Цель

Разрешает классы с разрозненными интерфейсами работать вместе, создавая общий объект, с помощью которого они могут общаться и взаимодействовать.

#### Использовать Когда

- Класс, который будет использоваться, не отвечает требованиям интерфейса.
- Сложные условия связывают поведение объекта с его состоянием.
- Переходы между государствами должны быть явными.

#### пример

Приложение биллинга должно взаимодействовать с приложением HR для обмена данными о сотрудниках, однако каждый из них имеет свой собственный интерфейс и реализацию для объекта Employee. Кроме того, SSN хранится в разных форматах каждой системой. Создавая адаптер, мы можем создать общий интерфейс между двумя приложениями, который позволяет им общаться с использованием своих собственных объектов и способен преобразовывать формат SSN в процесс.

РАЗДЕЛ 14

## Структурный объект моста

![Схема диаграммы моста](https://dzone.com/storage/rc-covers/10621-thumb.png)

### Цель

Определяет структуру абстрактного объекта независимо от структуры объекта реализации, чтобы ограничить связь.

#### Использовать Когда

- Абстракции и реализации не должны быть связаны во время компиляции.
- Абстракции и реализации должны быть независимо расширяемы.
- Изменения в реализации абстракции не должны влиять на клиентов.
- Детали реализации должны быть скрыты от клиента.

#### пример

Виртуальная машина Java (JVM) имеет свой собственный набор функций, которые абстрагируют использование оконного, системного ведения журнала и выполнения байтового кода, но фактическая реализация этих функций делегируется операционной системе, в которой работает JVM. Когда приложение указывает JVM на визуализацию окна, он делегирует вызов рендеринга конкретной реализации JVM, который знает, как взаимодействовать с операционной системой для визуализации окна.

РАЗДЕЛ 15

## Структурный составной объект

![Композитная диаграмма](https://dzone.com/storage/rc-covers/10622-thumb.png)

### Цель

Облегчает создание иерархии объектов, где каждый объект может обрабатываться независимо или как набор вложенных объектов через один и тот же интерфейс.

#### Использовать Когда

- Требуются иерархические представления объектов.
- Объекты и составы объектов должны обрабатываться равномерно.

#### пример

Иногда информация, отображаемая в корзине покупок, является продуктом одного элемента, а в других случаях это агрегирование нескольких элементов. Реализуя элементы как композиты, мы можем обрабатывать агрегаты и элементы таким же образом, позволяя нам просто перебирать дерево и вызывать функциональные возможности для каждого элемента. Вызвав метод getCost () на любом узле, мы получим стоимость этого элемента плюс стоимость всех дочерних элементов, позволяя единообразно обрабатывать элементы, будь то отдельные элементы или группы элементов.

РАЗДЕЛ 16

## Конструктор объекта

![Диаграмма рисунка декоратора](https://dzone.com/storage/rc-covers/10623-thumb.png)

### Цель

Позволяет динамически обертывать объекты для изменения существующих обязанностей и поведения.

#### Использовать Когда

- Обязанности и поведение объектов должны быть динамически модифицируемыми.
- Конкретные реализации должны быть отделены от обязанностей и поведения.
- Подклассификация для достижения модификации нецелесообразна или невозможна.
- Конкретная функциональность не должна находиться в иерархии объектов.
- Приемлемо множество мелких объектов, окружающих конкретную реализацию.

#### пример

Многие компании создали свои почтовые системы, чтобы воспользоваться декораторами. Когда сообщения отправляются от кого-то из компании во внешний адрес, почтовый сервер украшает исходное сообщение информацией об авторских правах и конфиденциальности. Пока сообщение остается внутренним, информация не прилагается. Это украшение позволяет самому сообщению оставаться неизменным до тех пор, пока не будет принято решение об окончании сообщения с дополнительной информацией.

РАЗДЕЛ 17

## Структурный объект фасада

![Схема диаграммы фасада](https://dzone.com/storage/rc-covers/10624-thumb.png)

### Цель

Поставляет единый интерфейс для набора интерфейсов в системе.

#### Использовать Когда

- Для обеспечения доступа к сложной системе необходим простой интерфейс.
- Существует множество зависимостей между реализацией системы и клиентами.
- Системы и подсистемы должны быть слоистыми.

#### пример

Предоставляя набор функциональных возможностей через веб-службу, клиентскому коду нужно только беспокоиться о простом интерфейсе, который им подвергается, а не о сложных отношениях, которые могут или не могут существовать за уровнем веб-сервиса. Один вызов веб-службы для обновления системы с новыми данными может фактически включать связь с несколькими базами данных и системами, однако эта деталь скрыта из-за реализации шаблона фасада.

РАЗДЕЛ 18

## Конструкция

![Схема диаграммы тяги](https://dzone.com/storage/rc-covers/10625-thumb.png)

### Цель

Облегчает повторное использование многих мелкозернистых объектов, что делает использование большого количества объектов более эффективным.

#### Использовать Когда

- Многие подобные объекты используются, а стоимость хранения высокая.
- Большинство состояний каждого объекта могут быть сделаны внешними.
- Несколько общих объектов могут заменить многие не разделенные.
- Идентичность каждого объекта не имеет значения.

#### пример

Системы, которые позволяют пользователям определять собственные потоки приложений и макеты, часто требуют отслеживания большого количества полей, страниц и других элементов, которые почти идентичны друг другу. Путем превращения этих элементов в ведомости все экземпляры каждого объекта могут делить внутреннее состояние, сохраняя при этом внешнее состояние отдельно. Внутреннее состояние будет хранить общие свойства, например, как выглядит текстовое поле, сколько данных он может хранить и какие события он предоставляет. Внешнее состояние будет хранить нерасширенные свойства, например, когда элемент принадлежит, как реагировать на щелчок пользователя и как обрабатывать события.

РАЗДЕЛ 19

## Прокси-объект

![Схема прокси-диаграммы](https://dzone.com/storage/rc-covers/10626-thumb.png)

### Цель

Позволяет контролировать доступ к уровню объекта, действуя как проход через объект или объект-заполнитель.

#### Использовать Когда

- Представляемый объект является внешним по отношению к системе.
- Объекты должны создаваться по требованию.
- Требуется контроль доступа для исходного объекта.
- При доступе к объекту требуется дополнительная функциональность.

#### пример

Приложения Ledger часто предоставляют пользователям возможность согласовывать свои банковские выписки с данными своих регистров по требованию, автоматизируя большую часть процесса. Фактическая работа связи с третьим лицом - относительно дорогостоящая операция, которая должна быть ограничена. Используя прокси-сервер для представления объекта связи, мы можем ограничить количество раз или интервалы, которые вызывают связь. Кроме того, мы можем обернуть сложную инстанцирование объекта связи внутри класса прокси, развязывая код вызова из деталей реализации.

РАЗДЕЛ 20

## Аннотация Создание объекта объекта

![Абстрактная диаграмма фабричной диаграммы](https://dzone.com/storage/rc-covers/10627-thumb.png)

### Цель

Предоставьте интерфейс, который делегирует вызовы создания одному или нескольким конкретным классам для доставки определенных объектов.

#### Использовать Когда

- Создание объектов должно быть независимым от используемой системы.
- Системы должны быть способны использовать несколько семейств объектов.
- Семьи объектов должны использоваться вместе.
- Библиотеки должны быть опубликованы без раскрытия деталей реализации.
- Конкретные классы должны быть отделены от клиентов.

#### пример

Редакторы электронной почты позволят редактировать в нескольких форматах, включая текст, текст и HTML. В зависимости от используемого формата необходимо создать различные объекты. Если сообщение является простым текстом, может существовать объект тела, который представляет собой простой текст и объект вложения, который просто зашифровал вложение в Base64. Если сообщение является HTML, объект body будет представлять текст, закодированный в HTML, а объект вложения будет иметь встроенное представление и стандартное вложение. Используя абстрактную фабрику для создания, мы можем затем обеспечить, чтобы соответствующие наборы объектов были созданы в зависимости от стиля отправляемой электронной почты.

РАЗДЕЛ 21

## Создание объекта объекта Builder

![Структурная диаграмма строителя](https://dzone.com/storage/rc-covers/10628-thumb.png)

### Цель

Позволяет динамически создавать объекты на основе легко взаимозаменяемых алгоритмов.

#### Использовать Когда

- Алгоритмы создания объектов должны быть отделены от системы.
- Требуются множественные представления алгоритмов создания.
- Необходимо добавить новую функциональность создания без изменения кода ядра.
- Требуется управление временем выполнения процесса создания.

#### пример

Приложение передачи файлов может использовать множество разных протоколов для отправки файлов, и фактический объект передачи, который будет создан, будет напрямую зависеть от выбранного протокола. Используя построитель, мы можем определить правильный строитель, который будет использоваться для создания экземпляра правильного объекта. Если параметр FTP, то при создании объекта будет использоваться построитель FTP.

РАЗДЕЛ 22

## Фабричный метод создания объекта

![Заводская диаграмма](https://dzone.com/storage/rc-covers/10629-thumb.png)

### Цель

Предоставляет метод создания объектов, позволяя подклассам контролировать фактический процесс создания.

#### Использовать Когда

- Класс не будет знать, какие классы он должен будет создавать.
- Подклассы могут указывать, какие объекты должны быть созданы.
- Родительские классы хотят отложить создание своих подклассов.

#### пример

Многие приложения имеют определенную форму пользовательской и групповой структуры для обеспечения безопасности. Когда приложение должно создавать пользователя, оно обычно делегирует создание пользователя нескольким пользовательским реализациям. Родительский пользовательский объект будет обрабатывать большинство операций для каждого пользователя, но подклассы будут определять фабричный метод, который обрабатывает различия при создании каждого типа пользователя. В системе могут быть объекты AdminUser и StandardUser, каждый из которых расширяет объект User. Объект AdminUser может выполнять дополнительные задачи для обеспечения доступа, в то время как StandardUser может сделать то же самое, чтобы ограничить доступ.

РАЗДЕЛ 23

## Создание прототипа объекта

![Схема шаблонов прототипов](https://dzone.com/storage/rc-covers/10630-thumb.png)

### Цель

Создавайте объекты на основе шаблона существующих объектов путем клонирования.

#### Использовать Когда

- Состав, создание и представление объектов должны быть отделены от системы.
- Создаваемые классы указываются во время выполнения.
- В объекте существует ограниченное количество комбинаций состояний.
- Требуются объекты или структуры объектов, которые идентичны или близки к другим существующим объектам или структурам объектов.
- Первоначальное создание каждого объекта - дорогостоящая операция.

#### пример

Двигатели обработки данных часто требуют поиска множества различных значений конфигурации, что делает инициализацию двигателя относительно дорогостоящим процессом. Если требуется несколько экземпляров ядра, скажем, для импорта данных в многопоточном режиме затраты на инициализацию многих двигателей высоки. Используя шаблон прототипа, мы можем гарантировать, что нужно инициализировать только одну копию двигателя, а затем просто клонировать движок, чтобы создать дубликат уже инициализированного объекта. Дополнительным преимуществом этого является то, что клоны могут быть оптимизированы, чтобы включать только соответствующие данные для их ситуации.

РАЗДЕЛ 24

## Создание Singleton Object Creation

![Схема диаграммы Singleton](https://dzone.com/storage/rc-covers/10631-thumb.png)

### Цель

Обеспечивает, чтобы в системе допускался только один экземпляр класса.

#### Использовать Когда

- Требуется один экземпляр класса.
- Требуется контролируемый доступ к одному объекту.

#### пример

Большинство языков предоставляют какой-то объект системы или среды, который позволяет языку взаимодействовать с собственной операционной системой. Поскольку приложение физически работает только в одной операционной системе, требуется только один экземпляр этого системного объекта. Шаблон singleton будет реализован языковой средой выполнения, чтобы гарантировать создание только одной копии системного объекта и обеспечить доступ к ним только для соответствующих процессов.